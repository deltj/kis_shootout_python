#!/usr/bin/env python3

import argparse
from datetime import datetime
from enum import Enum
import getpass
import signal
import sys
import time

import KismetRest

# Flag to tell the program to exit
die = False

# Current program state. Syncing means we're waiting for cards to be tuned to
# the specified channel, Collecting means the cards are tuned and we're counting
# frames
class State(Enum):
    Syncing = 1,
    Collecting = 2

# This object stores information about a data source we're tracking
class SourceInfo:
    name = ""       # The name of this data source
    uuid = 0        # Kismet's UUID for this data source
    count = 0       # The number of frames observed by this data source
    last_count = 0  # The previous number of frames observed by this data source
    offset = 0      # Frame count offset (to account for sync time)
    hardware = ""

def signal_handler(sig, frame):
    global die

    if sig == signal.SIGINT:
        print("Caught SIGINT")
        sys.exit(0)

def have_source(kr, source_name):
    """
    This function determines whether the specified datasource is known to
    the Kismet server that KismetRest is currently connected to.

    Arguments:
    kr -- A KismetRest object that is already connected to a Kismet server
    source_name -- The name of a datasource to look for
    """
    datasources = kr.datasources()
    for ds in datasources:
        if ds['kismet.datasource.name'] == source_name:
            return True

    return False

def have_interface(kr, interface_name):
    """
    This function determines whether the specified interface is known to
    the Kismet server that KismetRest is currently connected to.

    Arguments:
    kr -- A KismetRest object that is already connected to a Kismet server
    interface_name -- The name of an interface to look for
    """
    interfaces = kr.datasource_list_interfaces()
    for interface in interfaces:
        if interface['kismet.datasource.probed.interface'] == interface_name:
            return True

    return False

def get_max(sources_by_name):
    max_packets = 0

    for source_name, source in sources_by_name.items():
        if source.count > max_packets:
            max_packets = source.count

    return max_packets


if __name__ == "__main__":
    sources_by_name = dict()

    # Register signal handler for SIGINT (CTRL+C) 
    signal.signal(signal.SIGINT, signal_handler)

    parser = argparse.ArgumentParser(description="Kismet datasource shootout")
    parser.add_argument("sources", metavar="SRC", nargs="+",
            help="data sources to use in the shootout (e.g. wlan0)")
    parser.add_argument("-c", dest="channel", required=True,
            help="the channel to monitor")
    parser.add_argument("-u", dest="user",
            help="a user name to log into Kismet with")
    parser.add_argument("-p", dest="ask_for_password", action="store_true",
            help="tells this program to prompt for a password")
    parser.add_argument("-P", dest="password",
            help="a password to log into Kismet with")
    parser.add_argument("-s", dest="server", default="localhost",
            help="ip/hostname of kismet server (defaults to localhost")

    # Process command-line arguments
    args = parser.parse_args()

    username = ""
    if args.user:
        username = args.user

    password = ""
    if args.password:
        password = args.password

    if args.ask_for_password:
        password = getpass.getpass()

    for source_name in args.sources:
        si = SourceInfo()
        si.name = source_name
        sources_by_name[source_name] = si

    if len(sources_by_name) < 2:
        print("A shootout with only one data source is uninteresting, but whatever...")

    # URI for accessing Kismet
    uri = "http://{}:2501".format(args.server)
    print("Connecting to Kismet Server {}".format(uri))

    # Connect to Kismet
    kr = KismetRest.KismetConnector(uri)
    #kr.set_debug(True)
    kr.set_login(username, password)

    if not kr.check_session():
        print("Invalid login")
        sys.exit(1)

    # Make sure Kismet actually has the specified sources
    for source_name, source in sources_by_name.items():
        if not have_source(kr, source_name):
            # The specified source wasn't found, check if there's an interface
            # available by that name and enable it if so
            if have_interface(kr, source_name):
                try:
                    if kr.add_datasource("{}:type=linuxwifi,expand_ht20=true,channel_hop=false,channel={}".format(source_name, args.channel)):
                        print("Added datasource {}".format(source_name))
                    else:
                        print("Failed to add datasource {}".format(source_name))
                        sys.exit(1)
                except KismetRest.KismetRequestException:
                    print("Failed to add datasource {}".format(source_name))
            else:
                print("Kismet doesn't have a source named {}".format(source_name))
                sys.exit(1)

    # Update data source UUIDs
    datasources = kr.datasources()
    for source_name, source in sources_by_name.items():
        for ds in datasources:
            if ds['kismet.datasource.name'] == source.name:
                source.uuid = ds['kismet.datasource.uuid']
                source.hardware = ds['kismet.datasource.hardware']
        if source.uuid == 0:
            print("Kismet doesn't have a source named {}".format(source.name))
            sys.exit(1)

    # Tune data sources to the specified channel
    state = State.Syncing
    for source_name, source in sources_by_name.copy().items():
        print("Tuning data source {} to channel {}".format(source_name, args.channel))

        try:
            # This could throw a KismetRequestException if the tune fails
            kr.config_datasource_set_channel(source.uuid, args.channel)

        except KismetRest.KismetRequestException:
            print("Failed to tune {} to {}, ignoring this datasource".format(source_name, args.channel))

            # Remove this datsource from the list
            sources_by_name.pop(source_name)

    # Make sure there are still some data sources to poll
    # (it's possible they all failed to tune?)
    if len(sources_by_name) < 1:
        print("No sources to test!")
        sys.exit(1)

    while True:

        # Check that our session is still valid
        if not kr.check_session():
            print("check_session failed")
            kr.login()

        datasources = kr.datasources()

        if state == State.Syncing:
            all_tuned = True

            for ds in datasources:
                ds_name = ds['kismet.datasource.name']
                ds_chan = ds['kismet.datasource.channel']

                # Is this a source we care about?
                if ds_name in sources_by_name:

                    # Has this card tuned yet?
                    if ds_chan == args.channel:
                        # Yes, update its offset
                        sources_by_name[ds_name].offset = ds['kismet.datasource.num_packets']
                        print("Offset for {} = {}".format(ds_name, sources_by_name[ds_name].offset))
                    else:
                        all_tuned = False

            if all_tuned:
                # All sources have tuned to the specified channel
                state = State.Collecting

                # Make note of the start of collection time
                start_time = datetime.now()
            
        elif state == State.Collecting:
            print('\x1bc')
            
            # Print a column header
            print("Source      Hardware       PPS     Packets        RX %")
            print("------------------------------------------------------")

            # Update packet counters
            for ds in datasources:
                ds_name = ds['kismet.datasource.name']
                ds_count = ds['kismet.datasource.num_packets']

                # Is this a source we care about?
                if ds_name in sources_by_name:

                    # Yup, update packet counter
                    sources_by_name[ds_name].last_count = sources_by_name[ds_name].count
                    sources_by_name[ds_name].count = ds_count - sources_by_name[ds_name].offset

            max_count = get_max(sources_by_name)
            if max_count == 0: max_count = 1

            for source_name, source in sources_by_name.items():
                #print("{} {} ({:.2%})".format(ifc, count, count / max_count))
                color = ''
                percent = source.count / max_count
                #colors by percent
                if percent < .75:
                    color = '\033[91m'
                elif percent < .90:
                    color = '\033[93m'
                else:
                    color = '\033[94m'
                #highlight failures in red
                if ( source.count - source.last_count ) < 1:
                    color = '\033[91m'
                print("{}{:<12}{:<12}{:>6}{:>12}{:>12.2%}\033[0m".format(
                    color,
                    source_name,
                    source.hardware,
                    source.count - source.last_count,
                    source.count,
                    percent))

            time_delta = datetime.now() - start_time
            m, s = divmod(int(time_delta.total_seconds()), 60)
            h, m = divmod(m, 60)
            print("\nElapsed time: {} Hours {} Minutes {} Seconds".format(h, m, s))

        else:
            print("State error")
            sys.exit(1)

        time.sleep(1)

