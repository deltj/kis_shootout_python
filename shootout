#!/usr/bin/env python3

import argparse
from datetime import datetime
from enum import Enum
import getpass
import json
import logging
import requests
import signal
import sys
import time

# Current program state. Syncing means we're waiting for cards to be tuned to
# the specified channel, Collecting means the cards are tuned and we're counting
# frames
class State(Enum):
    Syncing = 1,
    Collecting = 2

# This object stores information about a data source we're tracking
class SourceInfo:
    name = ""       # The name of this data source
    uuid = 0        # Kismet's UUID for this data source
    count = 0       # The number of frames observed by this data source
    last_count = 0  # The previous number of frames observed by this data source
    offset = 0      # Frame count offset (to account for sync time)
    hardware = ""

def http_get(uri, timeout=1):
    """
    This function attempts to retrieve the specified URI using an HTTP GET request.
    If a timeout is specified, the function will wait at most that number of seconds.
    """
    logging.info(f"Making GET request to {uri}")

    start = time.time()

    response = None
    try:
        response = session.get(uri, timeout=timeout)

    except Exception as e:
        logging.error("HTTP GET failed for {} with exception: {}".format(uri, e))
        sys.exit(1)

    end = time.time()
    elapsed = end - start
    logging.info("Request took {0:.3f} seconds".format(elapsed))

    return response

def kis_get_bool(uri):
    """
    This function performs an HTTP GET for the specified URI, and returns True
    or False depending on the response code.
    """
    actual_uri = f"{base_uri}{uri}"
    response = http_get(actual_uri)

    if response.status_code == 200:
        return True
    else:
        return False

def kis_get_json(uri):
    """
    This function GETs the specified URI, expecting a JSON response.
    The JSON response is formatted into a python dictionary and returned.
    """
    actual_uri = f"{base_uri}{uri}"
    response = http_get(actual_uri)

    if response.status_code != 200:
        logging.error(f"HTTP GET failed for {actual_uri}")
        sys.exit(1)

    json_result = response.content.decode('utf-8')
    dict_result = json.loads(json_result)
    return dict_result

def kis_get_sources():
    """
    Return a dictionary of all available datasources on the kismet server
    """
    url = f"/datasource/all_sources.json"
    return kis_get_json(url)

def kis_get_interfaces():
    """
    Return a dictionary of all available interfaces on the kismet server
    """
    url = f"/datasource/list_interfaces.json"
    return kis_get_json(url)

def kis_check_session():
    return kis_get_bool("/session/check_session")

def kis_have_source(source_name):
    """
    This function determines whether the specified datasource is known to
    the Kismet server

    Arguments:
    source_name -- The name of a datasource to look for
    """
    sources = kis_get_sources()
    for source in sources:
        if source['kismet.datasource.name'] == source_name:
            return True
    
    return False

def kis_have_interface(interface_name):
    """
    This function determines whether the specified interface is known to
    the Kismet server

    Arguments:
    interface_name -- The name of an interface to look for
    """
    interfaces = kis_get_interfaces()
    for interface in interfaces:
        if interface['kismet.datasource.probed.interface'] == interface_name:
            return True

    return False

def get_max(sources_by_name):
    max_packets = 0

    for source_name, source in sources_by_name.items():
        if source.count > max_packets:
            max_packets = source.count

    return max_packets

def signal_handler(sig, frame):
    if sig == signal.SIGINT:
        print("Caught SIGINT")
        sys.exit(0)

if __name__ == "__main__":

    # Configure logging
    FORMAT = '[%(levelname)s] %(message)s'
    logging.basicConfig(stream=sys.stdout, format=FORMAT, level=logging.INFO)
    logger = logging.getLogger()

    # Register signal handler for SIGINT (CTRL+C) 
    signal.signal(signal.SIGINT, signal_handler)

    sources_by_name = dict()

    parser = argparse.ArgumentParser(description="Kismet datasource shootout")
    parser.add_argument("sources", metavar="SRC", nargs="+",
            help="data sources to use in the shootout (e.g. wlan0)")
    parser.add_argument("-c", dest="channel", required=True,
            help="the channel to monitor")
    parser.add_argument("-u", dest="user",
            help="a user name to log into Kismet with")
    parser.add_argument("-p", dest="ask_for_password", action="store_true",
            help="tells this program to prompt for a password")
    parser.add_argument("-P", dest="password",
            help="a password to log into Kismet with")
    parser.add_argument("-s", dest="server", default="localhost",
            help="ip/hostname of kismet server (defaults to localhost")

    # Process command-line arguments
    args = parser.parse_args()

    username = ""
    if args.user:
        username = args.user

    password = ""
    if args.password:
        password = args.password

    if args.ask_for_password:
        password = getpass.getpass()

    for source_name in args.sources:
        si = SourceInfo()
        si.name = source_name
        sources_by_name[source_name] = si

    # Configure HTTP client session
    session = requests.Session()
    session.auth = (username, password)

    # URI for accessing Kismet
    base_uri = "http://{}:2501".format(args.server)
    print("Connecting to Kismet Server {}".format(base_uri))

    # Verify login
    if not kis_check_session():
        print("Invalid login")
        sys.exit(1)
    else:
        print("Logged in!")

    if kis_have_interface("wlp69s0"):
        print("have")
    else:
        print("don't have")

    # Make sure Kismet actually has the specified sources
    #for source_name, source in sources_by_name.items():
        #if not have_source(source_name):
            #print("dang")
            # The specified source wasn't found, check if there's an interface
            # available by that name and enable it if so
            #if have_interface(source_name):
            #    if add_datasource("{}:type=linuxwifi,expand_ht20=true,channel_hop=false,channel={}".format(source_name, args.channel)):
            #        print("Added datasource {}".format(source_name))
            #    else:
            #        print("Failed to add datasource {}".format(source_name))
            #        sys.exit(1)
            #else:
            #    print("Kismet doesn't have a source named {}".format(source_name))
            #    sys.exit(1)

    """
    # Update data source UUIDs
    datasources = kr.datasources()
    for source_name, source in sources_by_name.items():
        for ds in datasources:
            if ds['kismet.datasource.name'] == source.name:
                source.uuid = ds['kismet.datasource.uuid']
                source.hardware = ds['kismet.datasource.hardware']
        if source.uuid == 0:
            print("Kismet doesn't have a source named {}".format(source.name))
            sys.exit(1)

    # Tune data sources to the specified channel
    state = State.Syncing
    for source_name, source in sources_by_name.copy().items():
        print("Tuning data source {} to channel {}".format(source_name, args.channel))

        try:
            # This could throw a KismetRequestException if the tune fails
            kr.config_datasource_set_channel(source.uuid, args.channel)

        except KismetRest.KismetRequestException:
            print("Failed to tune {} to {}, ignoring this datasource".format(source_name, args.channel))

            # Remove this datsource from the list
            sources_by_name.pop(source_name)

    # Make sure there are still some data sources to poll
    # (it's possible they all failed to tune?)
    if len(sources_by_name) < 1:
        print("No sources to test!")
        sys.exit(1)

    while True:

        # Check that our session is still valid
        if not kr.check_session():
            print("check_session failed")
            kr.login()

        datasources = kr.datasources()

        if state == State.Syncing:
            all_tuned = True

            for ds in datasources:
                ds_name = ds['kismet.datasource.name']
                ds_chan = ds['kismet.datasource.channel']

                # Is this a source we care about?
                if ds_name in sources_by_name:

                    # Has this card tuned yet?
                    if ds_chan == args.channel:
                        # Yes, update its offset
                        sources_by_name[ds_name].offset = ds['kismet.datasource.num_packets']
                        print("Offset for {} = {}".format(ds_name, sources_by_name[ds_name].offset))
                    else:
                        all_tuned = False

            if all_tuned:
                # All sources have tuned to the specified channel
                state = State.Collecting

                # Make note of the start of collection time
                start_time = datetime.now()
            
        elif state == State.Collecting:
            print('\x1bc')
            
            # Print a column header
            print("Source      Hardware       PPS     Packets        RX %")
            print("------------------------------------------------------")

            # Update packet counters
            for ds in datasources:
                ds_name = ds['kismet.datasource.name']
                ds_count = ds['kismet.datasource.num_packets']

                # Is this a source we care about?
                if ds_name in sources_by_name:

                    # Yup, update packet counter
                    sources_by_name[ds_name].last_count = sources_by_name[ds_name].count
                    sources_by_name[ds_name].count = ds_count - sources_by_name[ds_name].offset

            max_count = get_max(sources_by_name)
            if max_count == 0: max_count = 1

            for source_name, source in sources_by_name.items():
                #print("{} {} ({:.2%})".format(ifc, count, count / max_count))
                color = ''
                percent = source.count / max_count
                #colors by percent
                if percent < .75:
                    color = '\033[91m'
                elif percent < .90:
                    color = '\033[93m'
                elif percent == 1:
                    color = '\033[7;94m'
                else:
                    color = '\033[94m'
                #highlight failures in red
                if ( source.count - source.last_count ) < 1:
                    color = '\033[91m'
                print("{}{:<12}{:<12}{:>6}{:>12}{:>12.2%}\033[0m".format(
                    color,
                    source_name,
                    source.hardware,
                    source.count - source.last_count,
                    source.count,
                    percent))

            time_delta = datetime.now() - start_time
            m, s = divmod(int(time_delta.total_seconds()), 60)
            h, m = divmod(m, 60)
            print("\nElapsed time on channel {}: {} Hours {} Minutes {} Seconds".format(args.channel, h, m, s))

        else:
            print("State error")
            sys.exit(1)

        time.sleep(1)
    """

